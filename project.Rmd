---
title: "Code & Result"
output:
  html_document:
    toc: true
    toc_float: true
---

***

## Import Data
```{r setup, include=FALSE}
# Load in packages
library(devtools)
library(tidyverse)
library(readr)
library(readxl)
library(haven)
library(survey)
library(MEPS)
library(dplyr)

# Read "2023 MEPS" data
# 2023 Full-Year Consolidated（HC-251）
## Personnel expenses + Demographics + Sampling design variables
fyc23  <- read_MEPS(file = "h251")
cond23 <- read_MEPS(file = "h249")

## Read "2023 Medical Conditions" data（HC-249）
## Diseases / CCSR
names(fyc23)  <- tolower(names(fyc23))
names(cond23) <- tolower(names(cond23))

des23 <- svydesign(
  ids    = ~varpsu,
  strata = ~varstr,
  weights= ~perwt23f,
  data   = fyc23,
  nest   = TRUE
)
```


```{r}
# This chunk only need to run in "Console" once, do not run when knitting the file
# devtools::install_github("e-mitchell/meps_r_pkg/MEPS")
# library(MEPS)
```


```{r}
# Quick check of the total fee variable (totexp23)
summary(fyc23$totexp23)
# check if the name of first few variables correct
names(fyc23)[1:30]
grep("23", names(fyc23), value = TRUE)[1:20]
nrow(fyc23) 
```
 
## Clean data "fyc23"
```{r}
fyc23_clean <- fyc23

# Only keep the individuals with positive weight
fyc23_clean <- fyc23_clean[fyc23_clean$perwt23f > 0, ]

# Change all the missing value (-1, -7, -8, -9, -15) into NA
num_vars <- sapply(fyc23_clean, is.numeric)

for (j in which(num_vars)) {
  x <- fyc23_clean[[j]]
  x[x %in% c(-1, -7, -8, -9, -15)] <- NA
  fyc23_clean[[j]] <- x
}

# Only keep the variables needed for this project (could extend later)
keep_vars <- c(
  "dupersid", "panel", "varstr", "varpsu", "perwt23f",
  "totexp23",           # Total fee
  "agelast", "sex", "racethx",
  "povcat23", "inscov23"
)

fyc23_clean <- fyc23_clean[ , keep_vars]

# Use cleaned data to rebuild "survey design"
des23 <- svydesign(
  ids    = ~varpsu,
  strata = ~varstr,
  weights= ~perwt23f,
  data   = fyc23_clean,
  nest   = TRUE
)

```

### Demografic Variables
```{r}
# 2.1 Build blank variable columns

fyc23_clean$age_cat4  <- NA
fyc23_clean$sex_f     <- NA
fyc23_clean$race4     <- NA
fyc23_clean$povcat_f  <- NA
fyc23_clean$inscov_f  <- NA

# 2.2 Age groups：0–17, 18–44, 45–64, 65+
fyc23_clean$age_cat4[fyc23_clean$agelast <= 17] <-
  "0-17"
fyc23_clean$age_cat4[fyc23_clean$agelast >= 18 &
                     fyc23_clean$agelast <= 44] <-
  "18-44"
fyc23_clean$age_cat4[fyc23_clean$agelast >= 45 &
                     fyc23_clean$agelast <= 64] <-
  "45-64"
fyc23_clean$age_cat4[fyc23_clean$agelast >= 65] <-
  "65+"

fyc23_clean$age_cat4 <- factor(
  fyc23_clean$age_cat4,
  levels = c("0-17", "18-44", "45-64", "65+")
)

# 2.3 Gender: 1=Male, 2=Female
fyc23_clean$sex_f[fyc23_clean$sex == 1] <- "Male"
fyc23_clean$sex_f[fyc23_clean$sex == 2] <- "Female"
fyc23_clean$sex_f <- factor(
  fyc23_clean$sex_f,
  levels = c("Male", "Female")
)

# 2.4 Race: NH White, NH Black, Hispanic, NH Asian/Other
fyc23_clean$race4[fyc23_clean$racethx == 1] <- "Hispanic"
fyc23_clean$race4[fyc23_clean$racethx == 2] <- "NH White"
fyc23_clean$race4[fyc23_clean$racethx == 3] <- "NH Black"
fyc23_clean$race4[fyc23_clean$racethx %in% c(4, 5)] <- "NH Asian/Other"

fyc23_clean$race4 <- factor(
  fyc23_clean$race4,
  levels = c("NH White", "NH Black", "Hispanic", "NH Asian/Other")
)

# 2.5 Poverty line groups (POVCAT23): 1–5
# In MEPS, High income = House income ≥ 4 times federal poverty line,
# not “top 1% / top 10% super rich”, but the population of middle-class and above

pov_labels <- c(
  "Poor", "Near-poor", "Low income",
  "Middle income", "High income"
)

fyc23_clean$povcat_f <- factor(
  fyc23_clean$povcat23,
  levels = 1:5,
  labels = pov_labels
)

# 2.6 Insurance type (INSCOV23): 1 any private, 2 public only, 3 uninsured
ins_labels <- c("Any private", "Public only", "Uninsured")

fyc23_clean$inscov_f <- factor(
  fyc23_clean$inscov23,
  levels = 1:3,
  labels = ins_labels
)

# 2.7 Use updated data to rebuild "design"
des23 <- svydesign(
  ids    = ~varpsu,
  strata = ~varstr,
  weights= ~perwt23f,
  data   = fyc23_clean,
  nest   = TRUE
)

# Quick check
svytable(~ age_cat4, des23)
svytable(~ race4, des23)
svytable(~ povcat_f, des23)
svytable(~ inscov_f, des23)

```

```{r}
# Explore the relationship between "agelast" and "age_cat4"
table(fyc23_clean$age_cat4, useNA = "ifany")

# For each age group, check the minimum/ maximum
tapply(
  fyc23_clean$agelast,
  fyc23_clean$age_cat4,
  function(x) range(x, na.rm = TRUE)
)

table(fyc23_clean$racethx, fyc23_clean$race4, useNA = "ifany")


table(fyc23_clean$povcat23, fyc23_clean$povcat_f, useNA = "ifany")


table(fyc23_clean$inscov23, fyc23_clean$inscov_f, useNA = "ifany")


```

Define Top 1%、Top 5%、Top 10%、Bottom 50%
```{r}
# Calculate the weighted quantile of "TOTEXP23"

# 3.1 Calculate weighted quantile
exp_cuts <- svyquantile(
  ~ totexp23,
  design    = des23,
  quantiles = c(0.50, 0.90, 0.95, 0.99),
  ci        = FALSE
)

exp_cuts   # check it when knitting
str(exp_cuts)
```


```{r}
q_vec <- as.numeric(exp_cuts$totexp23)

# quantile of: 0.50, 0.90, 0.95, 0.99
p50 <- q_vec[1]  # 0.5 分位数
p90 <- q_vec[2]  # 0.9
p95 <- q_vec[3]  # 0.95
p99 <- q_vec[4]  # 0.99

# Create variable "exp_group"
fyc23_clean$exp_group <- NA

fyc23_clean$exp_group[fyc23_clean$totexp23 >= p99] <- "Top 1%"
fyc23_clean$exp_group[fyc23_clean$totexp23 >= p95 &
                      fyc23_clean$totexp23 <  p99] <- "Top 5%"
fyc23_clean$exp_group[fyc23_clean$totexp23 >= p90 &
                      fyc23_clean$totexp23 <  p95] <- "Top 10%"
fyc23_clean$exp_group[fyc23_clean$totexp23 <= p50] <- "Bottom 50%"

# 50–90%
fyc23_clean$exp_group[
  is.na(fyc23_clean$exp_group) &
    !is.na(fyc23_clean$totexp23)
] <- "50–90%"

fyc23_clean$exp_group <- factor(
  fyc23_clean$exp_group,
  levels = c("Bottom 50%", "50–90%", "Top 10%", "Top 5%", "Top 1%")
)

# Use data with "exp_group" to rebuild "design"
des23 <- svydesign(
  ids    = ~varpsu,
  strata = ~varstr,
  weights= ~perwt23f,
  data   = fyc23_clean,
  nest   = TRUE
)

# Check the weighted number and proportion of people in each expense category
svytable(~ exp_group, des23)
svytable(~ exp_group, des23) / sum(weights(des23))

```

## Clean data "cond23"
```{r}
# A copy from "cond23"
cond23_clean <- cond23

# Numeric variable: missing value -> NA
num_vars_c <- sapply(cond23_clean, is.numeric)

for (j in which(num_vars_c)) {
  x <- cond23_clean[[j]]
  x[x %in% c(-1, -7, -8, -9, -15)] <- NA
  cond23_clean[[j]] <- x
}

# CCSR (characteristic), column names are: ccsr1x, ccsr2x, ccsr3x, ccsr4x
ccsr_cols <- grep("^ccsr", names(cond23_clean), value = TRUE)

for (nm in ccsr_cols) {
  x <- cond23_clean[[nm]]
  # Some files using "-1" or "-15" as missing value
  x[x %in% c("-1", "-15")] <- NA
  cond23_clean[[nm]] <- x
}

# Main CCSR: use "ccsr1x" first, use 2/3/4 when data missing
cond23_clean$ccsr_main <- cond23_clean$ccsr1x

idx_na <- is.na(cond23_clean$ccsr_main) & !is.na(cond23_clean$ccsr2x)
cond23_clean$ccsr_main[idx_na] <- cond23_clean$ccsr2x[idx_na]

idx_na <- is.na(cond23_clean$ccsr_main) & !is.na(cond23_clean$ccsr3x)
cond23_clean$ccsr_main[idx_na] <- cond23_clean$ccsr3x[idx_na]

idx_na <- is.na(cond23_clean$ccsr_main) & !is.na(cond23_clean$ccsr4x)
cond23_clean$ccsr_main[idx_na] <- cond23_clean$ccsr4x[idx_na]

# Only keep the record of the main CCSR is not missing
cond23_clean <- cond23_clean[!is.na(cond23_clean$ccsr_main), ]

# Only keep the variables that will be used later
keep_cond_vars <- c(
  "dupersid", "condidx",
  "varstr", "varpsu", "perwt23f",
  "ccsr_main"
)

cond23_clean <- cond23_clean[ , keep_cond_vars]

# Check the first 10 CCSR
head( sort(table(cond23_clean$ccsr_main), decreasing = TRUE), 10 )
```

## Double Check
```{r}
## 1. Calculate the "Total population" under the survey design
total_pop <- sum(weights(des23))
total_pop
# Supposed to around the magnitude of 300 million

## 2. The weighted frequency of each variable
tab_age   <- svytable(~ age_cat4,  des23)
tab_race  <- svytable(~ race4,     des23)
tab_pov   <- svytable(~ povcat_f,  des23)
tab_ins   <- svytable(~ inscov_f,  des23)

## 3. The weighted sum of each variable, should be around total_pop
sum_age  <- sum(tab_age)
sum_race <- sum(tab_race)
sum_pov  <- sum(tab_pov)
sum_ins  <- sum(tab_ins)

c(
  total_pop = total_pop,
  sum_age   = sum_age,
  sum_race  = sum_race,
  sum_pov   = sum_pov,
  sum_ins   = sum_ins
)

## 4. Check the difference (should be close to 0, or with small rounding error)
c(
  age_minus_total  = sum_age  - total_pop,
  race_minus_total = sum_race - total_pop,
  pov_minus_total  = sum_pov  - total_pop,
  ins_minus_total  = sum_ins  - total_pop
)

```

```{r}
## Age distribution: weighted frequency + proportion
tab_age
prop_age <- prop.table(tab_age)
prop_age
sum(prop_age)  # should ≈ 1

## Race distribution
tab_race
prop_race <- prop.table(tab_race)
prop_race
sum(prop_race)  # ≈ 1

## Poverty line distribution
tab_pov
prop_pov <- prop.table(tab_pov)
prop_pov
sum(prop_pov)  # ≈ 1

## Insurance distribution
tab_ins
prop_ins <- prop.table(tab_ins)
prop_ins
sum(prop_ins)  # ≈ 1
```

```{r}
## Check the sample number of each age group (non-weighted)
table(fyc23_clean$age_cat4, useNA = "ifany")

## Check the minimum/maximum of "agelast" in each age group
tapply(
  fyc23_clean$agelast,
  fyc23_clean$age_cat4,
  function(x) range(x, na.rm = TRUE)
)
```

```{r}
## racethx -> race4, mapping table
table(fyc23_clean$racethx, fyc23_clean$race4, useNA = "ifany")

## povcat23 -> povcat_f
table(fyc23_clean$povcat23, fyc23_clean$povcat_f, useNA = "ifany")

## inscov23 -> inscov_f
table(fyc23_clean$inscov23, fyc23_clean$inscov_f, useNA = "ifany")

```

```{r}
## Weighted frequency of expense groups
tab_exp <- svytable(~ exp_group, des23)
tab_exp

## Weighted proportion of expense groups
prop_exp <- prop.table(tab_exp)
prop_exp
sum(prop_exp)  # ≈ 1
```

## Regression Model

Quantify how demographics, socioeconomic status, and medical conditions are associated with belonging to the high-cost group.

```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(purrr)
library(survey)
```

```{r}
# create n_ccsr to record multi-morbidity
person_ccsr <- cond23_clean %>% 
  group_by(dupersid) %>% 
  summarise(
    n_ccsr = n_distinct(ccsr_main),   # number of diseases with different CCSR 
    .groups = "drop"
  ) %>% 
  mutate(
    multi_morbidity = if_else(n_ccsr >= 3, 1, 0)  # threshold can be customized
  )
```

Add a few binary disease index for regression covariates.

```{r}
ccsr_counts <- cond23_clean %>% 
  count(ccsr_main, sort = TRUE)

head(ccsr_counts,10)

ccsr_top20 <- ccsr_counts %>% 
  slice_max(n, n = 20)

ggplot(ccsr_top20,
       aes(x = reorder(ccsr_main, n),
           y = n)) +
  geom_col() +
  coord_flip() +
  labs(
    x = "CCSR category",
    y = "Number of condition records",
    title = "Top 20 most common CCSR condition categories (unweighted)"
  )
```


```{r}
# recheck using weight
ccsr_w_counts <- cond23_clean %>% 
  group_by(ccsr_main) %>% 
  summarise(
    w_count = sum(perwt23f, na.rm = TRUE),
    .groups = "drop"
  ) %>% 
  arrange(desc(w_count))

ccsr_w_top20 <- ccsr_w_counts %>% 
  slice_max(w_count, n = 20)

ggplot(ccsr_w_top20,
       aes(x = reorder(ccsr_main, w_count),
           y = w_count)) +
  geom_col() +
  coord_flip() +
  labs(
    x = "CCSR category",
    y = "Weighted count of conditions",
    title = "Top 20 CCSR condition categories (weighted by PERWT23F)"
  )
```

```{r}
# compare top 10 ccsr
data.frame(
  unweighted_top10 = ccsr_counts$ccsr_main[1:10],
  weighted_top10   = ccsr_w_counts$ccsr_main[1:10]
)

ccsr_union <- union(ccsr_counts$ccsr_main[1:10], ccsr_w_counts$ccsr_main[1:10])
ccsr_union
```

```{r}
ccsr_main_values <- unique(cond23_clean$ccsr_main)

# create binary variable for each ccsr in ccsr_union
for (disease in ccsr_union) {
  var_name <- disease
  # check whether the person has that disease
  person_ccsr[[var_name]] <- ifelse(
    person_ccsr$dupersid %in% cond23_clean$dupersid[cond23_clean$ccsr_main == disease],
    1, 
    0
  )
}

```

```{r}
fyc23_model <- fyc23_clean %>%
  left_join(person_ccsr, by = "dupersid") %>% 
  mutate(high_cost = ifelse(exp_group == "Top 5%", 1, 0))
# set outcome variable as 'whether the person is in the top 5% expenses group'
         

des_model <- svydesign(
  ids     = ~varpsu,
  strata  = ~varstr,
  weights = ~perwt23f,
  data    = fyc23_model,
  nest    = TRUE
)
```

### Feature Selection


```{r}
# baseline model
baseline_formula <- high_cost ~ 
  age_cat4 + sex_f + race4 + povcat_f + inscov_f + n_ccsr

model_baseline <- svyglm(
  baseline_formula,
  design = des_model,
  family = quasibinomial()
)
summary(model_baseline)
```

```{r}
# full model
ccsr_vars <- c("CIR007","END010","MUS010","END002","MBD005",          "MBD002","END001","MUS006","DIG004","RSP009","INJ031")

full_formula <- update(
  baseline_formula,
  paste(". ~ . +", paste(ccsr_vars, collapse = " + "))
)

model_full <- svyglm(
  full_formula,
  design = des_model,
  family = quasibinomial()
)
summary(model_full)

```

```{r}
# model with selected significant variables
selected_vars <- c(
  "age_cat4",
  "sex_f",
  "povcat_f",
  "inscov_f",
  "n_ccsr",
  "END010","END002","MBD005","MBD002","END001","RSP009"
)

full_formula2 <- as.formula(
  paste("high_cost ~", paste(selected_vars, collapse = " + "))
)


model_selected <- svyglm(
  full_formula2,
  design = des_model,
  family = quasibinomial()
)

summary(model_selected)

```


```{r}
AIC(model_baseline)
AIC(model_full)
AIC(model_selected)
```
```{r}
# cv validation
cv_rmse <- function(formula, data, K = 5) {
  n <- nrow(data)
  folds <- sample(rep(1:K, length.out = n))
  
  rmse_vec <- numeric(K)
  
  for (k in 1:K) {
    train <- data[folds != k, ]
    test  <- data[folds == k, ]
    
    fit <- glm(formula, data = train, family = binomial())
    
  
    p_hat <- predict(fit, newdata = test, type = "response")
    
    # RMSE between predicted probability and actual 0/1
    rmse_vec[k] <- sqrt(mean((p_hat - test$high_cost)^2))
  }
  
  rmse_vec
}

```

```{r}
set.seed(1234)
n_rep <- 10
K <- 5

df_cv <- fyc23_model %>%
  select(
    high_cost,
    age_cat4, sex_f, race4, povcat_f, inscov_f, n_ccsr,
    CIR007, END010, MUS010, END002, MBD005, MBD002, END001, MUS006, DIG004, RSP009, INJ031
  )%>%
  drop_na() %>%                            
  mutate(
    high_cost = as.numeric(high_cost),      
   
  )

cv_results <- map_dfr(1:n_rep, ~{
  tibble(
    model = "Baseline",
    rmse  = cv_rmse(baseline_formula, df_cv, K = K)
  ) %>%
    bind_rows(
      tibble(
        model = "Full",
        rmse  = cv_rmse(full_formula, df_cv, K = K)
      ),
      tibble(
        model = "Selected",
        rmse  = cv_rmse(full_formula2, df_cv, K = K)
      )
    )
})
```


```{r}
ggplot(cv_results, aes(x = model, y = rmse)) +
  geom_violin(trim = FALSE, fill = NA, color = "lightblue") +
  geom_boxplot(width = 0.15, fill = "white", outlier.size = 0.5) +
  labs(
    x = NULL,
    y = "Cross-validated RMSE",
    title = "Cross-validated prediction error for three models"
  ) +
  theme_minimal()
```

